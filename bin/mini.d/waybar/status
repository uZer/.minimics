#!/usr/bin/env bash
# display status of various system process for waybar

set -eu

# Pretty print command name
COMMAND=${0//\// }
COMMAND=${COMMAND/*mini.d/mini}

DISPLAY_WIFI_SIGNAL=false

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-

get_usage () {
  cat << EOF
display various information in waybar

usage:
  $COMMAND --help, -h
  $COMMAND <arg>

arguments:
  -h, --help   display this message
  netif        display default interface for internet connectivity
  ip           display public ip
  player       display playerctl status
  ts           display tailscale status for waybar
  tsp          display tailscale peers for waybar tooltip
EOF
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-

status_player () {
  metadata=$(playerctl metadata --format 2>/dev/null \
    '{{lc(status)}} {{artist}} - {{title}} {{lc(playerName)}}')
  status=$(awk '{print $1}' <<< "$metadata")
  info=$(awk '{$1=""; print substr($0,2)}' <<< "$metadata")  # everything except the status

  # Map specific status and player name to icon keywords
  case "$status" in
    paused) status="pause" ;;
    playing) status="play" ;;
  esac

  # Extract player name (assumes it's the last word)
  player_name=$(awk '{print $NF}' <<< "$info")
  [[ "$player_name" == "plexamp" ]] && player_name="plex" # plexamp → plex
  # Remove player name from info
  info="${info% "$player_name"}"
  icon_status=$(mini nf convert "$status")
  icon_player=$(mini nf convert "$player_name")

  # Print final output
  printf "%s %s %s\n" "$icon_status" "$info" "$icon_player"
}

status_public_ip () {
  ip="$(curl -s --max-time 2 'https://api64.ipify.org' || true)"
  if [[ "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    jq -cM <<EOF
{
  "text": " ${ip}",
  "tooltip": "exit using IPv4\n\nright clic: copy IPv4",
  "class": "online"
}
EOF
  elif [[ "$ip" =~ ^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$ ]]; then
    ipv4="$(curl -s --max-time 2 'https://api.ipify.org' || true)"
    jq -cM <<EOF
{
  "text": "󰼔 $ipv4",
  "tooltip": "$ip",
  "class": "online"
}
EOF
  else
    jq -cM <<EOF
{
  "text": "󰅤",
  "tooltip": "offline",
  "class": "offline"
}
EOF
  fi
}

status_netif () {
  # Get default route interface
  iface=$(ip route get 1.1.1.1 2>/dev/null |
    awk '{for(i=1;i<=NF;i++) if($i=="dev") print $(i+1); exit}')

  # Exit if no interface
  if [[ -z "$iface" ]]; then
    jq -cM <<EOF
{
  "text": "",
  "tooltip": "No network connection",
  "class": "disconnected"
}
EOF
    exit 0
  fi

  # Determine link type (wifi/ethernet/other)
  type=$(nmcli -t -f DEVICE,TYPE device | grep "^$iface:" | cut -d: -f2)
  [ -z "$type" ] && type="unknown"

  # Pick icon based on type
  case "$type" in
    wifi)
      signal=$(nmcli -t -f IN-USE,SSID,SIGNAL device wifi list | grep '^\*' | cut -d: -f3)
      if [[ -n "$signal" ]]; then
        if [[ "$DISPLAY_WIFI_SIGNAL" = "true" ]]; then
          value=" ${signal}%"
        else
          value=""
        fi
        if (( signal > 80 )); then icon="󰤨${value}"
        elif (( signal > 60 )); then icon="󰤥${value}"
        elif (( signal > 40 )); then icon="󰤢${value}"
        elif (( signal > 20 )); then icon="󰤟${value}"
        else icon="󰤯"  # weak signal
        fi
      else
        icon="󰖩"  # no signal info
      fi
      class="wifi"
      ;;

    ethernet) icon=""; class="wired" ;;
    *)        icon="󰘚"; class="other" ;;
  esac

  # Check carrier/status
  state=$(cat /sys/class/net/"$iface"/operstate 2>/dev/null || echo "down")
  [[ "$state" != "up" ]] && class="${class}-disconnected"

  jq -cM <<EOF
{
  "text": "$icon",
  "tooltip": "$iface",
  "class": "$class"
}
EOF
}

status_ts () {
  # If Tailscale unit isn't running
  if ! systemctl is-active --quiet tailscaled; then
    exit 0
  fi

  # Fetch json status
  json=$(tailscale status --json 2>/dev/null || echo "")

  # If Tailscale isn't running or has no output
  if [[ -z "$json" ]] || ! echo "$json" | jq -e '.BackendState == "Running"' >/dev/null; then
    jq -cM <<EOF
{
  "text": "󰇘",
  "tooltip": "Tailscale is disconnected",
  "class": "disconnected"
}
EOF
    exit 0
  fi

  # Trim DNS name to hostname only (remove MagicDNSSuffix)
  tailnet=$(echo "$json" | jq -r '.MagicDNSSuffix')
  peers=$(status_ts_peers | jq -Rs .)
  # "tooltip": "connected as $my_name\n\npeers:\n" +$peers,

  # Check if ExitNodeStatus exists
  exit_node_status=$(echo "$json" | jq -r 'try .ExitNodeStatus // empty')
  if [[ -z "$exit_node_status" ]]; then
    # No exit node — normal connection
    is_advertising_exit=$(echo "$json" | jq -r 'try .Self.ExitNodeOption // empty')
    if [[ -n "$is_advertising_exit" ]]; then
      text="󱗼 󰩈"
    else
      text="󱗼"
    fi
    jq -cM <<EOF
{
  "text": "$text",
  "tooltip": $peers,
  "class": "connected"
}
EOF
    exit 0
  fi

  # Extract exit node peer info
  exit_id=$(echo "$json" | jq -r '.ExitNodeStatus.ID')
  exit_online=$(echo "$json" | jq -r '.ExitNodeStatus.Online')
  exit_still_advertising=$(echo "$json" | jq -r --arg id "$exit_id" '.Peer[] | select(.ID == $id) | .ExitNodeOption')
  exit_name=$(echo "$json" | jq -r --arg id "$exit_id" '.Peer[] | select(.ID == $id) | .DNSName')

  # Trim exit node DNS name
  if [[ "$exit_name" == *"$tailnet." ]]; then
    exit_name="${exit_name/%.${tailnet}./}"
  fi

  if [[ "$exit_online" == "true" ]] && [[ "$exit_still_advertising" == "true" ]]; then
    jq -cM <<EOF
{
  "text": "󱗼 󰴽 $exit_name",
  "tooltip": $peers,
  "class": "exit-online"
}
EOF
  else
    jq -cM <<EOF
{
  "text": "󱗼 via $exit_name ()",
  "tooltip": $peers,
  "class": "exit-offline"
}
EOF
  fi
}

status_ts_peers () {
  json=$(tailscale status --json 2>/dev/null || echo "")
  [[ -z "$json" ]] && echo "No Tailscale data" && return

  echo -n '<span font-family="mono" font-size="8pt">'
  echo "$json" | jq -r '
    def ago:
      sub("\\..*"; "Z")
      | fromdateiso8601 as $date
      | (now - $date) as $diff
      | if $diff < 60 then "just now"
        elif $diff < 3600 then ((($diff / 60) | floor | tostring) + "m ago")
        elif $diff < 86400 then ((($diff / 3600) | floor | tostring) + "h ago")
        else ((($diff / 86400) | floor | tostring) + "d ago")
      end;

    . as $root
    | ([ $root.Self ] + ($root.Peer | to_entries | map(.value)))[]
    | {
        id: .ID,
        ip: (.TailscaleIPs[0] // "unknown"),
        raw_dns: .DNSName,
        user_id: (.UserID | tostring),
        os: (.OS // "unknown" | ascii_downcase),
        active: (.Active // false),
        online: (.Online // false),
        exit: (.ExitNodeOption // false),
        last_seen: (.LastSeen // null),
        is_self: (.ID == $root.Self.ID)
      }
    | .dns = (
        if .raw_dns | endswith("." + $root.MagicDNSSuffix + ".") then
          (.raw_dns | sub("\\." + $root.MagicDNSSuffix + "." + "$"; ""))
        else .raw_dns end
      )
    | .user = (
        $root.User[.user_id]?.DisplayName // "unknown"
      )
    | .os_icon = (
        if .os | test("ios") then "󰀷"
        elif .os | test("win") then "󰖳"
        elif .os | test("android") then ""
        elif .os | test("linux") then ""
        elif .os | test("mac|darwin") then ""
        else "" end
      )
    | .exit_icon = if .exit == true then "󰗼" else "" end
    | .status = (
        if .is_self == true then
          "<span>󰋜</span>"
        elif .active == true then
          "<span></span>"
        elif .online == false then
          "<span> " + (.last_seen | ago) + "</span>"
        else
          "<span></span>"
        end
      )
    | "\(.user);\(.dns);(\(.ip));\(.os_icon);\(.exit_icon);\(.status)"
  ' | sort | column -t -s ';' | sed 's#\t#  #g'
  echo '</span>'
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-

[ $# -lt 1 ] && get_usage && exit 0

case "$1" in
  -h|--help|"")
    get_usage
    ;;
  netif)
    status_netif
    ;;
  ip)
    status_public_ip
    ;;
  player)
    status_player
    ;;
  ts)
    status_ts
    ;;
  tsp)
    status_ts_peers
    ;;
  *)
    logg err "unknown option '$1'"
    get_usage
    exit 1
    ;;
esac
